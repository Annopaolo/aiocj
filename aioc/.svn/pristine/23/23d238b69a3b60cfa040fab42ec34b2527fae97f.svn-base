package org.epp.impl;

import java.net.URI;
import java.util.HashMap;
import java.util.HashSet;

import org.aioc.Aioc;
import org.aioc.Choreography;
import org.aioc.FunctionLocation;
import org.aioc.IfThenElse;
import org.aioc.LocalAssignmentCommand;
import org.aioc.Scope;
import org.aioc.SeqBlock;
import org.aioc.While;
import org.aioc.util.AiocSwitch;
import org.eclipse.emf.common.util.EList;

import jolie.lang.NativeType;
import jolie.lang.parse.ast.OutputPortInfo;
import jolie.lang.parse.ast.RequestResponseOperationDeclaration;
import jolie.lang.parse.ast.types.TypeInlineDefinition;
import jolie.util.Range;

public class FunctionCollector extends AiocSwitch< Boolean >{
	
	private final HashMap< String, HashMap< String, HashSet< OutputPortInfo > > > roleScopePorts =
			new HashMap< String, HashMap< String, HashSet< OutputPortInfo > > >();
	private HashMap< String, OutputPortInfo > functionPorts =
			new HashMap< String, OutputPortInfo >();
	private String scope;
	
	public FunctionCollector(){}
	
	public void collect( Choreography choreography, Aioc aioc ){
		if( aioc != null ){
			assignOutputPorts( aioc.getFunctionLocation() );			
			this.scope=JolieEppUtils.MAIN_SCOPE;
		}
		if( choreography != null ){ doSwitch( choreography ); }
	}
	
	public HashMap< String, HashMap< String, HashSet< OutputPortInfo > > > 
	collectScope( 
			Choreography choreography,
			HashMap< String, OutputPortInfo > functionPorts,
			String scopeKey ){
		this.scope=scopeKey;
		this.functionPorts = functionPorts;
		collect( choreography, null);
		return roleScopePorts;
	}
	
	public Boolean caseScope( Scope scope ){
		System.out.println( "Visiting scope \"" + scope.getKey() + "\"" );
		FunctionCollector fc = new FunctionCollector();
		fc.setFunctionOutputPort( functionPorts );
		fc.collectScope( scope.getChoreography(), functionPorts, scope.getKey() );
		mergeRoleScopePorts( fc.getRoleScopePorts() );
		return true;
	}
	
	public Boolean caseChoreography( Choreography n ){
		doSwitch( n.getSeqBlock() );
		if( n.getNext() != null ){ doSwitch( n.getNext() ); }
		return true;
	}
	
	public Boolean caseSeqBlock( SeqBlock n ){
		doSwitch( n.getEvent() );
		if ( n.getNext() != null ){ doSwitch( n.getNext() ); }
		return true;
	}
	
	public Boolean caseWhile( While n ){
		doSwitch( n.getChoreography() );
		return true;
	}
	
	public Boolean caseIfThenElse( IfThenElse n ){
		doSwitch( n.getThen() );
		if( n.getElse() != null ){
			doSwitch( n.getElse() );
		}
		return true;
	}
	
	public Boolean caseLocalAssignmentCommand( LocalAssignmentCommand n ){
		if( n.getFunction() !=null ){
			if( !roleScopePorts.containsKey( n.getThread() )){
				HashMap< String, HashSet< OutputPortInfo > > sout = 
						new HashMap< String, HashSet< OutputPortInfo > >();
				sout.put( scope, new HashSet< OutputPortInfo >());
				roleScopePorts.put( n.getThread(), sout);
			}
			roleScopePorts.get( n.getThread() ).get( scope ).add(	
					functionPorts.get( n.getFunction().getName() ));
			System.out.println( "added port " + 
					functionPorts.get( n.getFunction().getName() ) +
					" to " + n.getThread() + " in scope \"" + this.scope + "\"" );
			
		}
		return true;
	}

	public HashSet< OutputPortInfo > getRoleOutputPorts( String role ){
		return roleScopePorts.get( role ).get( JolieEppUtils.MAIN_SCOPE );
	}
	
	public HashSet< OutputPortInfo > getScopeOutputPorts( String role, String scopeKey ){
		System.out.println( "Getting ports of scope " + scopeKey + " of role " + role );
		if( roleScopePorts.containsKey( role ) ){
			return roleScopePorts.get( role ).get( scopeKey );
		} else {
			return new HashSet< OutputPortInfo >();
		}
	}
	
	public OutputPortInfo getFunctionOutputPort( String function ){
		return functionPorts.get( function );
	}
	
	public void setFunctionOutputPort( HashMap< String, OutputPortInfo > functionPorts ){
		this.functionPorts = functionPorts;
	}
	
	public HashMap< String, HashMap< String, HashSet< OutputPortInfo > > > getRoleScopePorts(){
		return roleScopePorts;
	}

	private void mergeRoleScopePorts(
			HashMap< String, HashMap< String, HashSet< OutputPortInfo > > > rsp ){
		for( String role : rsp.keySet() ){
			if( !roleScopePorts.containsKey( role ) ){
				roleScopePorts.put( role, new HashMap< String, HashSet< OutputPortInfo >>() );
			}
			for( String scopeKey: rsp.get( role ).keySet() ){
				System.out.println( "Adding " + rsp.get( role ).get( scopeKey )
						+ " to " + role + " in scope \"" + scopeKey + "\"" );
				roleScopePorts.get( role ).put( scopeKey, rsp.get( role ).get( scopeKey ) );				
			}
		}
	}

	private void assignOutputPorts( EList<FunctionLocation> functionLocation ) {
		if( functionLocation != null ){
			for( FunctionLocation fl : functionLocation ){
				OutputPortInfo o = new OutputPortInfo( 
						JolieEppUtils.PARSING_CONTEXT,
						"Port" + functionLocation.indexOf( fl ) );
				o.setLocation( URI.create( fl.getLocation() ) );
				if( fl.getProtocol() != null ){
					o.setProtocolId( fl.getProtocol() );
				} else {
					o.setProtocolId( "sodep" );
				}
				for( String fs : fl.getFunctions().getFunctionName() ){									
					RequestResponseOperationDeclaration r = new RequestResponseOperationDeclaration(
							JolieEppUtils.PARSING_CONTEXT, 
							fs,
							new TypeInlineDefinition(
								JolieEppUtils.PARSING_CONTEXT, 
								"undefined", NativeType.ANY,
								new Range(1, 1)), 
							new TypeInlineDefinition(
								JolieEppUtils.PARSING_CONTEXT, 
								"undefined", NativeType.ANY,
								new Range(1, 1)), 
								null);
					o.addOperation( r );
					functionPorts.put( fs , o );
				}
			}
		}
		System.out.println("Assigned ports to functions" + functionPorts.toString() );
	}

}
