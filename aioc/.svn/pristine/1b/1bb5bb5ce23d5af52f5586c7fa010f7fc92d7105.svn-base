/***************************************************************************
 *   Copyright (C) 2011-2012 by Fabrizio Montesi <famontesi@gmail.com>     *
 *   Copyright (C) 2011 by Marco Carbone <carbonem@itu.dk>                 *
 *   Copyright (C) 2013-2014 by Saverio Giallorenzo <sgiallor@cs.unibo.it> *
 *   Copyright (C) 2013-2014 by Ivan Lanese <lanese@cs.unibo.it>           *
 *   Copyright (C) 2013-2014 by Jacopo Mauro <jmauro@cs.unibo.it>          *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU Library General Public License as       *
 *   published by the Free Software Foundation; either version 2 of the    *
 *   License, or (at your option) any later version.                       *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   You should have received a copy of the GNU Library General Public     *
 *   License along with this program; if not, write to the                 *
 *   Free Software Foundation, Inc.,                                       *
 *   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             *
 *                                                                         *
 *   For details about the authors of this software, see the AUTHORS file. *
 ***************************************************************************/

grammar org.Aioc with org.eclipse.xtext.common.Terminals

generate aioc "http://www.aioc.org"

AiocJ:
	( aioc = Aioc	| ruleSet+=Rule* )
;

Aioc:
	( functionLocation += FunctionLocation )*
	"preamble" LCURLY ( preamble = Preamble )	RCURLY
		"aioc" LCURLY	(choreography = Choreography ) RCURLY
;

Rule:
	"rule" LCURLY
		"on" LCURLY ( where = Where )	RCURLY
		"do" LCURLY choreography=Choreography RCURLY 
	RCURLY
;

Where:
	whereCondition=WhereCompareCondition
;

WhereExpressionBasicTerm: "N." nVariable = ID | 
													"E." eVariable = ID | 
													sVariable=ID
;

WhereCompareCondition:
	( ( leftExpression = WhereExpressionBasicTerm
	operator=ConditionOperator
	rightExpression=Expression ) | true ?= TRUE | false ?= FALSE )
	( logicOp = WhereLogicOp continuation = WhereCompareCondition )?
;

WhereLogicOp:
	and ?= AND
	|
	or ?= OR
;

Preamble:
	"starter:" starter = ID
	( locDefinition = LocationDefinition )?
;

FunctionLocation:
	"include" functions = FunctionList 
	"from" location = STRING
	("with" protocol = STRING)?
;

FunctionList:
	functionName += ID (COMMA functionName += ID)*
;

LocationDefinition:
	"location" AT role = ID COLON location = STRING
	( continuation=LocationDefinition )?
;

Choreography:
	seqBlock = SeqBlock ( PIPE next = Choreography )?
;

SeqBlock:
	event = ( Skip | Interaction | LocalCode | IfThenElse | 
		While | Scope | NestedChoreography
	) 
	( SEMICOLON next = SeqBlock )?
;

Skip:
	skip ?= "skip"
;

Interaction:
	operation = ID COLON
	sender = ID LPAREN
		( senderExpression = ExpressionBasicTerm )?
	RPAREN ARROW
	receiver = ID LPAREN
		( receiverVariable = ID )?
	RPAREN 
;


// Local thread code
LocalCode:
	// Ask a question to the user, e.g. result@thr = getInput( question )
	{LocalAskCommand}
	resultVariable = ID AT thread = ID ASSIGN "getInput" LPAREN question = Expression RPAREN
	|
	// Show some text, e.g. show@thr("Hello, world!")
	{LocalShowCommand}
	variable = ID AT thread = ID ASSIGN "show" LPAREN expression = Expression RPAREN
	|
	// Make an internal state assignment var@thr = e
	{LocalAssignmentCommand}
	variable = ID AT thread = ID ASSIGN ( expression = Expression | function = Function ) 
;

/**
 * if (condition)@thread { Choreography } else { Choreography }
 */
IfThenElse:
	( key = ID COLON )? 'if' LPAREN condition = Condition RPAREN AT thread = ID 
		LCURLY then = Choreography RCURLY
	( 'else' LCURLY else = Choreography RCURLY )?
;

/*
 * while (condition)@thread { Choreography }
 */
While:
	'while' LPAREN condition = Condition RPAREN AT thread = ID 
		LCURLY choreography = Choreography RCURLY
		( LCURLY key = ID RCURLY )?
;

//Scope code
Scope:
	'scope' AT thread = ID 
	LCURLY ( choreography = Choreography ) RCURLY
	( 'prop' LCURLY properties = AssignmentSet RCURLY )?
	( 'roles' LCURLY roles = Roles RCURLY )?
	( LCURLY key = ID RCURLY )?
;

Roles:
	roles += ID ( COMMA roles += ID )*
;

//nested Choreography code
NestedChoreography:
	LCURLY
		choreography = Choreography
	RCURLY
;

/*** Assignment ***/
AssignmentSet:
	assignment = Assignment (COMMA continuation = AssignmentSet)?
;

Assignment:
	"N."variable = ID ASSIGN expression = Expression
;

/*** Expressions and conditions ***/

Expression:
	sumExpression = SumExpression;

SumExpression:
	children += ExpressionBasicTerm (children += SumExpressionTerm)*;

SumExpressionTerm:
	{SumExpressionAddTerm} PLUS expression = ExpressionBasicTerm
	|
	{SumExpressionSubtractTerm} MINUS expression = ExpressionBasicTerm
;

ExpressionBasicTerm: variable = ID | constant = Constant | 
	LPAREN expression = Expression RPAREN
;

Function:
	name=ID LPAREN
		( params += Expression ( COMMA params += Expression )* )?
	RPAREN
;

Constant:
	intValue = INT | strValue = STRING | true = TRUE | false = FALSE
;

// Condition. Example: x < 5 AND x != 3
Condition:
	compareCondition = CompareCondition
;

CompareCondition:
	( 
		( leftExpression = Expression	operator = ConditionOperator 
			rightExpression = Expression
		) 
		| true ?= TRUE 
		| false ?= FALSE
	)
	( ( and ?= AND | or ?= OR ) next = CompareCondition )?
;

ConditionOperator:
	less ?= LESS
	|
	equal ?= EQUAL
	|
	greater ?= GREATER
	|
	not_equal ?= NOT_EQUAL
;

// Terminals
terminal LCURLY: '{';
terminal RCURLY: '}';
terminal ARROW: '->';
terminal SEMICOLON: ';';
terminal PIPE: '|';
terminal COLON: ':';
terminal PLUS: '+';
terminal MINUS: '-';
terminal AT: '@';
terminal ASSIGN: '=';
terminal DOT: '.';
terminal LPAREN: '(';
terminal RPAREN: ')';
terminal COMMA: ',';
terminal LESS: '<';
terminal EQUAL: '==';
terminal GREATER: '>';
terminal NOT_EQUAL: '!=';
terminal AND: 'and';
terminal OR: 'or';
terminal TRUE: "true";
terminal FALSE: "false";
